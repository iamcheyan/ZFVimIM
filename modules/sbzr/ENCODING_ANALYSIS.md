# 编码数量计算分析

## 核心规则

**只要上屏后，再输入的文字就是新的编码。永远都是这个规则。**

## 编码识别机制

### 1. 编码长度计算方式

编码长度通过以下方式计算：
```vim
let keyboard_len = start_column - seamless_column
```

其中：
- `start_column`: 当前光标位置
- `seamless_column`: 从光标位置向前查找，找到第一个**不是小写字母**的位置，或者从 `s:seamless_positions` 获取

### 2. 编码边界识别

系统通过 `s:input_keys = '^[a-z]$'` 来识别输入键（小写字母）。

**关键机制**：
- 当候选词上屏后，`s:seamless_positions[2]` 会被更新为候选词之后的位置（见 `s:didChoose()` 函数，2568行）
- 之后输入的任何小写字母都会从新的 `seamless_column` 开始，形成**新的编码**

## 输入 `xmzlsxmzls` 的行为分析

### 场景1：选择候选词上屏后继续输入

1. **输入 `xmzls`** → `keyboard_len = 5`，显示 `xmzls` 的候选词
2. **选择候选词上屏**（按空格或标签键）→ `s:seamless_positions` 更新到候选词之后
3. **输入 `xmzls`** → `keyboard_len = 5`（从新的位置开始），显示 `xmzls` 的候选词

**结果**：这是 **2 个独立的编码**。

### 场景2：不选择候选词，直接继续输入

1. **输入 `xmzls`** → `keyboard_len = 5`，显示 `xmzls` 的候选词
2. **继续输入 `x`** → `keyboard_len = 6`，系统认为这是**第6个字符**
   - 检查 `xmzlsx` 是否有匹配
   - 如果有匹配 → 显示 `xmzlsx` 的候选词
   - 如果没有匹配 → 继续累积
3. **继续输入 `mzls`** → `keyboard_len = 10`，显示 `xmzlsxmzls` 的候选词

**结果**：这是 **1 个编码（10个字符）**。

### 场景3：自动上屏后继续输入（4字符规则）

1. **输入 `xmzl`** → `keyboard_len = 4`，显示 `xmzl` 的候选词
2. **输入 `s`**（非标签键）→ 触发自动上屏逻辑：
   - 如果 `xmzls` 有匹配 → 正常输入 `s`，显示 `xmzls` 的候选词
   - 如果 `xmzls` 没有匹配 → 自动上屏 `xmzl` 的第一个候选词，然后 `s` 继续参与编码
3. **自动上屏后** → `s:seamless_positions` 更新到候选词之后
4. **继续输入 `xmzls`** → `keyboard_len = 5`（从新的位置开始），显示 `xmzls` 的候选词

**结果**：这是 **2 个独立的编码**。

## 编码边界识别规则

系统通过以下方式识别编码边界：

1. **选择候选词上屏后**：
   - `s:seamless_positions[2]` 更新为 `s:start_column + len(a:item['word'])`
   - 新的输入会从新的位置开始，形成新编码

2. **自动上屏后**：
   - 候选词上屏后，`s:seamless_positions` 也会更新
   - 新的输入会从新的位置开始，形成新编码

3. **非小写字母**：
   - 空格、标点、中文字符等会中断编码

## 总结

- **上屏后，再输入的文字就是新的编码** - 这是核心规则
- 如果用户不选择候选词，而是直接继续输入，系统会认为这是同一个编码的延续
- 要开始新编码，必须：
  1. 选择候选词上屏（手动或自动）
  2. 或者输入非小写字母（空格、标点等）

